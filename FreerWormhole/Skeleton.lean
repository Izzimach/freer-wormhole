-- Use wormhole to generate a tree-like data structure representing the freer monad.
-- We check for applications of bind/pure/ and convert them into branches and leaves of the tree.
-- When we see a command (usually generated by Freer.send) that gets it own leaf.
-- Splits such as if/then/else and pattern matches are mapped to "NonDet" since we
-- can't reliably evaluate the test. Also recursion has to be handled specially since
-- it doesn't fit into the pure/bind structure.

import Lean

import FreerWormhole.Effects.Freer
--import FreerWormhole.Effects.HEff
import FreerWormhole.Effects.StdEffs

import FreerWormhole.Wormhole

open Std.RBMap

open Lean Elab Command Meta Term

open Freer Effect HEffect Wormhole StdEffs



-- Skeleton representation of a (Freer effs x). When walking the Freer monad, commands
-- are converted into a type c and pure values are converted into a type t.
inductive FreerSkeleton (c t : Type) : Type where
| Error : String → FreerSkeleton c t
| Empty : FreerSkeleton c t
| Pure : t → FreerSkeleton c t
| Command : c → FreerSkeleton c t
| Bind : FreerSkeleton c t → FreerSkeleton c t → FreerSkeleton c t
| NonDet : FreerSkeleton c t → FreerSkeleton c t → FreerSkeleton c t
| Recursive : String → FreerSkeleton c t → FreerSkeleton c t
| Recurse : String → FreerSkeleton c t

mutual

def dumpFreerSkeleton [ToString c] [ToString t]: FreerSkeleton c t → String
    | .Error e => "Error : " ++ e
    | .Empty   => "Empty"
    | .Pure x => "Pure " ++ toString x
    | .Command c => "Command: " ++ toString c
    | .Bind a b => dumpFreerSkeleton a ++ " >>= " ++ dumpFreerSkeleton b
    | .NonDet a b => "(" ++ dumpFreerSkeleton a ++ " || " ++ dumpFreerSkeleton b ++ ")"
    | .Recursive s r => "{{Recursive " ++ s ++ " :: " ++ dumpFreerSkeleton r ++ "}}"
    | .Recurse s => "Call Recurse //" ++ s++ "//"

end

instance [ToString c] [ToString t] : ToString (FreerSkeleton c t) where
    toString := dumpFreerSkeleton

def listToNonDetFreer (targetType : Expr) (l : List Expr) : Expr :=
    match l with
    | List.nil => Lean.mkApp (Lean.mkConst ``FreerSkeleton.Empty) targetType
    | List.cons h List.nil => h
    | List.cons h t => Lean.mkAppN (Lean.mkConst ``FreerSkeleton.NonDet) #[targetType, h, listToNonDetFreer targetType t]

#check Bind.bind

namespace FreerSkel

-- given an expression of type "OU effs x" this extracts the effect and op
def unpackOU : Expr → TermElabM (Option (Expr × Expr)) := fun e =>
    match e.getAppFn with
    | .const c lvls => 
        if c.components.any (fun n => n == "inject")
        then do
            let args := e.getAppArgs
            let eff := args.get! 0
            let cmd ← instantiateMVars <| args.get! 3
            pure <| .some ⟨eff,cmd⟩
        else pure <| .none
    | _ => pure .none

def monadFuncs
    (cmdTransform : Expr → Expr → TermElabM Syntax) 
    (pureTransform : Expr → TermElabM Syntax) : 
        Std.RBMap String TransformerAppSyntax compare :=
    Std.RBMap.ofList
    [
        ⟨"send", fun args mk => do
            let eff := args.get! 0
            let op := args.get! 3
            let v ← cmdTransform eff op
            `(FreerSkeleton.Command $(TSyntax.mk v))
        ⟩,
        ⟨"Impure", fun args mk => do
            let effs := args.get! 0
            let ou := args.get! 3
            let cont := args.get! 4
            match (← unpackOU ou) with
            | .some ⟨eff,op⟩ => do
                let cmd ← cmdTransform eff op
                let r₂ ← mk true #[mkStrLit "bad argument"] cont
                `(FreerSkeleton.Bind (FreerSkeleton.Command $(TSyntax.mk cmd)) $(TSyntax.mk r₂))
            | .none => `(FreerSkeleton.Error "malformed command in Impure")
        ⟩,
        ⟨"bind", fun args mk => do
            let a₁ := args.get! 4
            let a₂ := args.get! 5
            let r₁ ← mk true #[] a₁
            let r₂ ← mk true #[mkStrLit "bad argument"] a₂
            `(FreerSkeleton.Bind $(TSyntax.mk r₁) $(TSyntax.mk r₂))
        ⟩,
        ⟨"Pure", fun args mk => do
            let a := args.get! 2
            let effs := args.get! 0
            let v ← pureTransform a
            withFreshMacroScope <| do
                /-let effsStx ← `(?effs)
                let effsVar ← elabTerm effsStx .none
                effsVar.mvarId!.assign effs
                let pureStx ← `(?a)
                let pureVar ← elabTerm pureStx .none
                pureVar.mvarId!.assign a-/
                `(FreerSkeleton.Pure $(TSyntax.mk v))
        ⟩,
        ⟨"pure", fun args mk => do
            let a := args.get! 3
            let v ← pureTransform a
            let pureId := args.get! 0
            let et := args.get! 2
            withFreshMacroScope <| do
                /-let pureStx ← `(?a)
                let pureVar ← elabTerm pureStx (.some et)
                pureVar.mvarId!.assign a-/
                --`(FreerSkeleton.Pure ?a)
                `(FreerSkeleton.Pure $(TSyntax.mk v))
        ⟩,
        -- if
        ⟨"ite", fun args mk => do
            logInfo <| args.get! 0
            let b₁ ← mk true args (args.get! 3)
            let b₂ ← mk true args (args.get! 4)
            `(FreerSkeleton.NonDet $(TSyntax.mk b₁) $(TSyntax.mk b₂))
        ⟩,
        -- decidible if
        ⟨"dite", fun args mk => do
            let b₁ ← mk true args (args.get! 3)
            let b₂ ← mk true args (args.get! 4)
            `(FreerSkeleton.NonDet $(TSyntax.mk b₁) $(TSyntax.mk b₂))
        ⟩,
        -- A recursive call
        ⟨"Recurse", fun args mk => do
            match args.get! 0 with
            | .lit (.strVal s) => `(FreerSkeleton.Recurse $(Syntax.mkStrLit s))
            | _ => `(FreerSkeleton.Recurse "Error: bad recurse id")
        ⟩,
        -- Wrapper around a recursive function
        ⟨"fix", fun args mk => do
            let recVar ← mkFreshExprMVar (mkConst ``String)
            let recId := recVar.mvarId!.name.toString
            recVar.mvarId!.assign (mkStrLit recId)
            let recFun := args.get! 4
            let recursiveCall := mkAppN (mkConst ``FreerSkeleton.Recurse) #[recVar]
            let recurseBody ← mk true #[mkStrLit "arg", recursiveCall] recFun
            `(FreerSkeleton.Recursive $(Syntax.mkStrLit recId) $(TSyntax.mk recurseBody))
        ⟩
    ]
    

--
-- some test monads
--


def noop3 [HasEffect NoopEffect m] : Freer m Nat := do noop; pure 3

def dumpArgh [HasEffect IOEffect m] : Nat → Freer m Nat := fun n => do
    if h : n = 0
    then pure 4
    else do
        ioEff0 (IO.println "argh")
        dumpArgh (n-1)


def wormHoleX : Freer [NoopEffect, IOEffect] Nat := do
    let z ← noop3
    if z < 3
        then dumpArgh 3
        else pure 3


-- this makes the pretty-printer show universe levels
set_option pp.universes true
set_option pp.fullNames true


#eval walkExpr ((do ioEff0 (IO.println "argh"); pure (ULift.up 4)) : Freer [IOEffect] (ULift Nat))
#eval walkExpr (noop : Freer [NoopEffect,IOEffect] PUnit)


def ProcessEffects := List (String × TermElabM Syntax)

def processE : ProcessEffects :=
    [
        ⟨"NoopEffect", `(fun (op : Type 1) (x : op) => "Noop!")⟩,
        ⟨"IOEffect", `(fun (op : Type 1) (o : StdEffs.IOX) => "IO!")⟩
    ]

def cmdX : ProcessEffects → Expr → Expr → TermElabM Syntax := fun pr eff op => do
    match eff.getAppFn with
    | .const effName lvls => do
        let eNameEnd := effName.components.getLastD "_"
        match List.lookup eNameEnd.toString pr with
        | .some fm => do
            withFreshMacroScope <| do
                let et ← inferType op
                let etStx ← `(?et)
                let opStx ← `(?op)
                let etVar ← elabTerm etStx .none
                let opVar ← elabTerm opStx (.some et)
                etVar.mvarId!.assign et
                opVar.mvarId!.assign op
                let f ← fm
                `($(TSyntax.mk f) ?et ?op)
        | .none => `("no handler for effect " ++ $(Syntax.mkStrLit effName.toString))
    | _ => `("malformed effect")

def pureX : Expr → TermElabM Syntax :=
    fun e => `(Unit.unit)


genWormhole2 skeltonize >: monadFuncs (cmdX processE) pureX :<

#check goWormhole2 (pure 3)
#check goWormhole2 (noop3 : Freer [NoopEffect] Nat)  --wormHoleX.{0}
#reduce goWormhole2 wormHoleX

--def x : FreerSkeleton String Unit := goWormhole2 wormHoleX

--#reduce x

--#eval goWormhole2 wormHoleX

end FreerSkel


namespace HEffSkel

open Effect HEffect StdEffs StdHEffs

def transact
    [HasHEffect (hLifted (StateEff Nat)) heffs]
    [HasHEffect (hLifted ThrowEff) heffs]
    [HasHEffect (CatchHEff (onlyRet Unit)) heffs]
      : Hefty heffs Nat :=
    do
    putH 1
    catchH
        (do putH 2; throwH)
        (do putH 3; pure ())
    getH


-- For higher-order effects (Hefty) we have to 
def heffFuncs
    (cmdTransform : Expr → Expr → TermElabM Syntax) 
    (heffTransform : Expr → Expr → Expr → ((a : Bool) → Array Expr → Expr → TermElabM (wormholeResult a)) → TermElabM Syntax)
    (pureTransform : Expr → TermElabM Syntax) : 
        Std.RBMap String TransformerAppSyntax compare :=
    let baseFuncs := FreerSkel.monadFuncs cmdTransform pureTransform
    List.foldl (fun a (Prod.mk s f) => a.insert s f) baseFuncs
        [
        ⟨"hLift", fun args mk => do
            let eff := args.get! 0
            let op := args.get! 3
            let v ← cmdTransform eff op
            `(FreerSkeleton.Command $(TSyntax.mk v))
        ⟩,
        ⟨"hSend", fun args mk => do
            logInfo args
            let heff := args.get! 1
            let cmd := args.get! 3
            let fork := args.get! 4
            let v ← heffTransform heff cmd fork mk
            `(FreerSkeleton.Command $(TSyntax.mk v))
        ⟩,
        ⟨"hBind", fun args mk => do
            let a₁ := args.get! 3
            let a₂ := args.get! 4
            let r₁ ← mk true #[] a₁
            let r₂ ← mk true #[mkStrLit "bad argument"] a₂
            `(FreerSkeleton.Bind $(TSyntax.mk r₁) $(TSyntax.mk r₂))
        ⟩
        ]

def heffX (heff : Expr) (cmd : Expr) (fork : Expr) (rec : (a : Bool) → Array Expr → Expr → TermElabM (wormholeResult a)) : TermElabM Syntax :=
    `("heffX")

def processE : List (String × TermElabM Syntax) :=
    [
        ⟨"StateEff", `(fun op (x : op) => "StateEff")⟩-- match x with | StateOp.Put _ => "PutState" | StateOp.Get => "GetState")⟩
    ]

genWormhole2 skeltonize >: heffFuncs (FreerSkel.cmdX processE) heffX FreerSkel.pureX :<

#check goWormhole2 (pure 3 : Freer [IOEffect] Nat)

#reduce goWormhole2 (@transact [CatchHEff (onlyRet PUnit), hLifted ThrowEff, hLifted (StateEff Nat)] _ _ _)

namespace HEffSkel