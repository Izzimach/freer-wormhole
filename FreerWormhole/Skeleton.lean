-- Use wormhole to generate a tree-like data structure representing the freer monad.
-- We check for applications of bind/pure/ and convert them into branches and leaves of the tree.
-- When we see a command (usually generated by Freer.send) that gets it own leaf.
-- Splits such as if/then/else and pattern matches are mapped to "NonDet" since we
-- can't reliably evaluate the test. Also recursion has to be handled specially since
-- it doesn't fit into the pure/bind structure.

import Lean

import FreerWormhole.Effects.Freer
--import FreerWormhole.Effects.HEff
import FreerWormhole.Effects.StdEffs

import FreerWormhole.Wormhole

open Std.RBMap

open Lean Elab Command Meta Term

open Freer Effect HEffect Wormhole StdEffs



inductive FreerSkeleton.{u} (effs : List Effect.{u}) (t : Type u) : Type (u+1) where
| Error : String → FreerSkeleton effs t
| Empty : FreerSkeleton effs t
| Pure : t → FreerSkeleton effs t
| Command : OU effs x → FreerSkeleton effs t
| Bind : FreerSkeleton effs t → FreerSkeleton effs t → FreerSkeleton effs t
| NonDet : FreerSkeleton effs t → FreerSkeleton effs t → FreerSkeleton effs t
| Recursive : String → FreerSkeleton effs t → FreerSkeleton effs t
| Recurse : String → FreerSkeleton effs t

mutual

def dumpFreerSkeleton {t : Type} [ToString t] : FreerSkeleton effs t → String
    | .Error e => "Error : " ++ e
    | .Empty   => "Empty"
    | .Pure t => "Pure " ++ toString t
    | .Command t => "Command: " --++ toString t
    | .Bind a b => dumpFreerSkeleton a ++ " >>= " ++ dumpFreerSkeleton b
    | .NonDet a b => "(" ++ dumpFreerSkeleton a ++ " || " ++ dumpFreerSkeleton b ++ ")"
    | .Recursive s r => "{{Recursive " ++ s ++ " :: " ++ dumpFreerSkeleton r ++ "}}"
    | .Recurse s => "Call Recurse //" ++ s++ "//"

def dumpHeff {t : Type} [ToString t] : List (FreerSkeleton effs t) → String
    | List.nil => ""
    | List.cons h t => dumpFreerSkeleton h ++ " |-| " ++ dumpHeff t

end

instance [ToString t] : ToString (FreerSkeleton effs t) where
    toString := dumpFreerSkeleton

def listToNonDetFreer (targetType : Expr) (l : List Expr) : Expr :=
    match l with
    | List.nil => Lean.mkApp (Lean.mkConst ``FreerSkeleton.Empty) targetType
    | List.cons h List.nil => h
    | List.cons h t => Lean.mkAppN (Lean.mkConst ``FreerSkeleton.NonDet) #[targetType, h, listToNonDetFreer targetType t]


namespace FreerSkel

def monadFuncs : Std.RBMap String TransformerApp compare :=
    Std.RBMap.ofList
    [
        ⟨"Impure", fun args mk => do
            let effs := args.get! 0
            let a₁ := args.get! 3
            let a₂ := args.get! 4
            let r₁ ← mk #[] a₁
            let r₂ ← mk #[mkStrLit "bad argument"] a₂
            pure <| mkAppN (mkConst ``FreerSkeleton.Bind [.zero]) #[effs, mkConst ``String, r₁,r₂]
        ⟩,
        ⟨"bind", fun args mk => do
            let bindId := args.get! 0
            match bindId.getAppFn with
            | .const n lvls => do
                let effs := bindId.getAppArgs.get! 0
                let a₁ := args.get! 4
                let a₂ := args.get! 5
                let r₁ ← mk #[] a₁
                let r₂ ← mk #[mkStrLit "Bad argument"] a₂
                pure <| mkAppN (mkConst ``FreerSkeleton.Bind lvls) #[effs, mkConst ``String, r₁,r₂]
            | _ => do
                logInfo "bind isnt app"
                pure <| mkStrLit "bind isnt app"
        ⟩,
        ⟨"inject", fun args mk => do
            let effs := args.get! 1
            pure <| mkAppN (mkConst ``FreerSkeleton.Pure) #[effs, mkConst ``String, mkStrLit "inject"]
        ⟩,
        ⟨"Pure", fun args mk => do
            let a₁ := args.get! 2
            pure <| mkAppN (mkConst ``FreerSkeleton.Pure) #[mkStrLit "pure"]
        ⟩,
        ⟨"pure", fun args mk => do
            let pureId := args.get! 0
            let et := args.get! 2
            let a := args.get! 3
            --logInfo pureId
            match pureId.getAppFn with
            | .const n lvls => do
                let pureEffs := pureId.getAppArgs.get! 0
                pure <| mkAppN (mkConst ``FreerSkeleton.Pure lvls) #[pureEffs, mkConst ``String, mkStrLit "?"]
            | _ => do
                logInfo "isntApp"
                pure <| mkStrLit "isntApp"
        ⟩,
        -- if
        ⟨"ite", fun args mk => do
            logInfo <| args.get! 0
            let b₁ ← mk args (args.get! 3)
            let b₂ ← mk args (args.get! 4)
            pure <| mkAppN (mkConst ``FreerSkeleton.NonDet [.zero]) #[b₁, b₂]
        ⟩,
        -- decidible if
        ⟨"dite", fun args mk => do
            let b₁ ← mk args (args.get! 3)
            let b₂ ← mk args (args.get! 4)
            pure <| mkAppN (mkConst ``FreerSkeleton.NonDet [.zero]) #[b₁, b₂]
        ⟩,
        -- A recursive call
        ⟨"Recurse", fun args mk => do
            pure <| mkAppN (mkConst ``FreerSkeleton.Recurse [.zero]) #[mkConst ``String, args.get! 0]
        ⟩,
        -- Wrapper around a recursive function
        ⟨"fix", fun args mk => do
            let recVar ← mkFreshExprMVar (mkConst ``String)
            recVar.mvarId!.assign (mkStrLit recVar.mvarId!.name.toString)
            let recFun := args.get! 4
            let recursiveCall := mkAppN (mkConst ``FreerSkeleton.Recurse) #[recVar]
            let recurseBody ← mk #[mkStrLit "arg", recursiveCall] recFun
            pure <| mkAppN (mkConst ``FreerSkeleton.Recursive) #[recVar, recurseBody]
        ⟩
    ]
    

--
-- some test monads
--


def noop3.{u} [HasEffect NoopEffect.{u+1} m] : Freer.{u+1} m (ULift Nat) := do noop; pure (ULift.up 3)

def dumpArgh.{u} [HasEffect IOEffect.{u} m] : Nat → Freer.{u+1} m (ULift Nat) := fun n => do
    if h : n = 0
    then pure (ULift.up 4)
    else do
        ioEff0 (IO.println "argh")
        dumpArgh (n-1)


def wormHoleX.{u} : Freer.{u+1} [NoopEffect.{u+1}, IOEffect.{u}] (ULift Nat) := do
    let z ← noop3
    if z.down < 3
        then dumpArgh 3
        else pure (ULift.up 3)

#eval walkExpr ((do ioEff0 (IO.println "argh"); pure (ULift.up 4)) : Freer [IOEffect] (ULift Nat))
#eval walkExpr (noop : Freer [NoopEffect,IOEffect] PUnit)
#print Nat.rec

--
-- generate the wormhole and try it out
--

genWormhole2 skeltonize >: monadFuncs :<


#check goWormhole2 (noop3.{0} : Freer [NoopEffect] (ULift Nat))--wormHoleX.{0}

--#eval goWormhole2 wormHoleX

end FreerSkel


namespace HEffSkel

open Effect HEffect StdEffs StdHEffs

def transact
    [HasHEffect (hLifted (StateEff Nat)) heffs]
    [HasHEffect (hLifted ThrowEff) heffs]
    [HasHEffect (CatchHEff (onlyRet Unit)) heffs]
      : Hefty heffs Nat :=
    do
    putH 1
    catchH
        (do putH 2; throwH)
        (do putH 3; pure ())
    getH

-- For higher-order effects (Hefty) we add to the wormhole transformers already built for Freer
def heffTransformers := 
    List.foldl (fun a (Prod.mk s f) => a.insert s f) FreerSkel.monadFuncs
        [
        ⟨"hLift", fun args mk => do
            pure <| mkAppN (mkConst ``FreerSkeleton.Pure) #[mkStrLit "hlift"]
        ⟩,
        ⟨"catchH", fun args mk => do
            logInfo args
            let tryE ← mk #[] (args.get! 3)
            let catchE ← mk #[] (args.get! 4)
            --let resultSyn ← `(FreerSkeleton.Pure "?")
            --let resultExpr ← elabType resultSyn
            let skelType := mkAppN (mkConst ``FreerSkeleton [.zero]) #[mkConst ``String]
            let lNil := mkAppN (mkConst ``List.nil [.zero]) #[skelType]
            let node2 ← mkAppM ``List.cons #[catchE,lNil]
            let node1 ← mkAppM ``List.cons #[tryE, node2]
            --let subnodes := mkAppN (mkConst ``List.cons [.zero]) #[tryE, mkAppN (mkConst ``List.cons [.zero]) #[catchE, mkConst ``List.nil]]
            pure <| mkAppN (mkConst ``FreerSkeleton.Heff [.zero]) #[mkConst ``String, mkStrLit "catch", node1]
        ⟩,
        ⟨"hBind", fun args mk => do
            pure <| mkAppN (mkConst ``FreerSkeleton.Pure) #[mkStrLit "hBind"]
        ⟩
        ]

-- this makes the pretty-printer show universe levels
set_option pp.universes true
--set_option pp.fullNames true

genWormhole2 skeltonize >: heffTransformers :<

#check goWormhole2 (pure (ULift.up 3) : Freer.{1} [IOEffect] (ULift Nat))

--#eval goWormhole2 (@transact [CatchHEff (onlyRet Unit), hLifted ThrowEff, hLifted (StateEff Nat)])

namespace HEffSkel