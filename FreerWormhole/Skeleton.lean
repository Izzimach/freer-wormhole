-- Use wormhole to generate a tree-like data structure representing the freer monad.
-- We check for applications of bind/pure/ and convert them into branches and leaves of the tree.
-- When we see a command (usually generated by Freer.send) that gets it own leaf.
-- Splits such as if/then/else and pattern matches are mapped to "NonDet" since we
-- can't reliably evaluate the test. Also recursion has to be handled specially since
-- it doesn't fit into the pure/bind structure.

import Lean

import FreerWormhole.Wormhole

open Wormhole

-- Skeleton representation of a (EffM effs x) or (HEffM heffs x). When walking the Freer monad, commands
-- are converted into a type c and pure values are converted into a type t.
inductive FreerSkeleton (c t : Type) : Type where
| Error : String → FreerSkeleton c t
| Empty : FreerSkeleton c t
| Pure : t → FreerSkeleton c t
| Command : c → FreerSkeleton c t
| Bind : FreerSkeleton c t → FreerSkeleton c t → FreerSkeleton c t
| NonDet : FreerSkeleton c t → FreerSkeleton c t → FreerSkeleton c t
| Recursive : String → FreerSkeleton c t → FreerSkeleton c t
| Recurse : String → FreerSkeleton c t
    deriving Repr


def dumpFreerSkeleton [ToString c] [ToString t]: FreerSkeleton c t → String
    | .Error e => "Error : " ++ e
    | .Empty   => "Empty"
    | .Pure x => "Pure " ++ toString x
    | .Command c => "Command: " ++ toString c
    | .Bind a b => dumpFreerSkeleton a ++ " >>= " ++ dumpFreerSkeleton b
    | .NonDet a b => "(" ++ dumpFreerSkeleton a ++ " || " ++ dumpFreerSkeleton b ++ ")"
    | .Recursive s r => "{{Recursive " ++ s ++ " :: " ++ dumpFreerSkeleton r ++ "}}"
    | .Recurse s => "Call Recurse //" ++ s++ "//"

namespace WormholeSkeleton

open Lean Elab Command Meta Term

open Wormhole


instance [ToString c] [ToString t] : ToString (FreerSkeleton c t) where
    toString := dumpFreerSkeleton

def listToNonDetFreer (targetType : Expr) (l : List Expr) : Expr :=
    match l with
    | List.nil => Lean.mkApp (Lean.mkConst ``FreerSkeleton.Empty) targetType
    | List.cons h List.nil => h
    | List.cons h t => Lean.mkAppN (Lean.mkConst ``FreerSkeleton.NonDet) #[targetType, h, listToNonDetFreer targetType t]

def skeletonTransformers
    (effTransform : ProcessEffect) 
    (heffTransform : ProcessHEffect)
    (direct : List (String × TransformerAppSyntax))
    (pureTransform : Expr → TermElabM Syntax)
    : List (String × TransformerAppSyntax) :=
    direct ++ [
        -- if
        ⟨"ite", fun args mk => do
            logInfo <| args.get! 0
            let b₁ ← mk true args (args.get! 3)
            let b₂ ← mk true args (args.get! 4)
            `(FreerSkeleton.NonDet $(TSyntax.mk b₁) $(TSyntax.mk b₂))
        ⟩,
        -- decidable if
        ⟨"dite", fun args mk => do
            let b₁ ← mk true args (args.get! 3)
            let b₂ ← mk true args (args.get! 4)
            `(FreerSkeleton.NonDet $(TSyntax.mk b₁) $(TSyntax.mk b₂))
        ⟩,
        -- A recursive call
        ⟨"Recurse", fun args mk => do
            match args.get! 0 with
            | .lit (.strVal s) => `(FreerSkeleton.Recurse $(Syntax.mkStrLit s))
            | _ => `(FreerSkeleton.Recurse "Error: bad recurse id")
        ⟩,
        -- Wrapper around a recursive function
        ⟨"fix", fun args mk => do
            let recVar ← mkFreshExprMVar (mkConst ``String)
            let recId := recVar.mvarId!.name.toString
            recVar.mvarId!.assign (mkStrLit recId)
            let recFun := args.get! 4
            let recursiveCall := mkAppN (mkConst ``FreerSkeleton.Recurse) #[recVar]
            let recurseBody ← mk true #[mkStrLit "arg", recursiveCall] recFun
            `(FreerSkeleton.Recursive $(Syntax.mkStrLit recId) $(TSyntax.mk recurseBody))
        ⟩,
        ⟨"send", fun args mk => do
            let eff := args.get! 0
            let op := args.get! 3
            let v ← effTransform eff op
            `(FreerSkeleton.Command $(TSyntax.mk v))
        ⟩,
        ⟨"hLift", fun args mk => do
            let heff := args.get! 0
            let op := args.get! 3
            let fork := args.get! 4
            let v ← heffTransform heff op fork mk
            `(FreerSkeleton.Command $(TSyntax.mk v))
        ⟩,
        ⟨"bind", fun args mk => do
            let a₁ := args.get! 4
            let a₂ := args.get! 5
            let r₁ ← mk true #[] a₁
            let r₂ ← mk true #[mkStrLit "bad argument"] a₂
            `(FreerSkeleton.Bind $(TSyntax.mk r₁) $(TSyntax.mk r₂))
        ⟩,
        ⟨"Pure", fun args mk => do
            let a := args.get! 2
            let v ← pureTransform a
            `(FreerSkeleton.Pure $(TSyntax.mk v))
        ⟩,
        ⟨"pure", fun args mk => do
            let a := args.get! 3
            let v ← pureTransform a
            `(FreerSkeleton.Pure $(TSyntax.mk v))
        ⟩]
    

def buildSkeletonWormhole (processors : List WormholeCallbacks) (processPure : Expr → TermElabM Syntax) : RBMap String TransformerAppSyntax compare :=
    let forEffects := List.join <| processors.map (fun w => w.effects)
    let forHEffects := List.join <| processors.map (fun w => w.heffects)
    let forDirect := List.join <| processors.map (fun w => w.direct)
    RBMap.fromList
        (skeletonTransformers
            (dispatchEffectProcessor forEffects)
            (dispatchHEffectProcessor forHEffects)
            forDirect processPure)
        compare

def pureUnit : Expr → TermElabM Syntax := fun _ => `(PUnit.unit)

def pureAsIs : Expr → TermElabM Syntax := fun e =>
    withFreshMacroScope <| do
        let et ← inferType e
        let pvStx ← `(?pv)
        let pvVar ← elabTerm pvStx (.some et)
        pvVar.mvarId!.assign e
        pure pvStx

-- Since foreverUntil is partial it won't show up in the normal wormhole transformation. So we
-- transform it into a loop via the recursive constructor.
def ForeverUntilSkeletonProcessor : WormholeCallbacks :=
    WormholeCallbacks.mk
        []
        []
        [⟨"foreverUntil", fun args mk => do
            let inLoop ← mk true #[] (args.get! 2)
            let recVar ← mkFreshExprMVar (mkConst ``String)
            let recId := recVar.mvarId!.name.toString
            recVar.mvarId!.assign (mkStrLit recId)
            -- we wrap the loop in .Recursive and some stuff onto the end after the loop:
            --  A nonet branch that either loops back (Recurse) or drops out of the loop (pure)
            `(FreerSkeleton.Recursive $(Syntax.mkStrLit recId)
                (FreerSkeleton.Bind
                    $(TSyntax.mk inLoop) 
                    (FreerSkeleton.NonDet
                        (FreerSkeleton.Recurse $(Syntax.mkStrLit recId))
                        (FreerSkeleton.Pure PUnit.unit))))
         ⟩]


end WormholeSkeleton


