-- Deconstruct freer monads generated by FreerMacro


import Lean
import Lean.Parser

open Lean Elab Expr Command Meta Term MVarId

namespace Wormhole

def spaceN (n : Nat) : String := String.mk <| List.replicate n ' '

partial
def goExpr (t : Expr) (indent : Nat) : MetaM Unit := do
  let preSpace := spaceN indent
  let dumpX := fun s => IO.println <| preSpace ++ s
  match (← instantiateMVars t) with
  | bvar ix => dumpX <| "bvar=" ++ toString ix
  | fvar fid => dumpX <| "fvar=" ++ toString fid.name
  | mvar mid => dumpX <| "mvar=" ++ toString mid.name
  | sort _ => dumpX <| "sort"
  | const n _ => dumpX <| "const=" ++ n.toString
  | app f arg => dumpX "app "; goExpr f (indent+1); goExpr arg (indent+1)
  | lam n arg body _ => dumpX ("lam > " ++ n.toString); goExpr arg (indent+1); goExpr body (indent+1)
  | forallE n a b _ => dumpX ("forall " ++ n.toString); goExpr a (indent+1); goExpr b (indent+1)
  | letE n t v b _ => do
      dumpX ("let " ++ n.toString)
      goExpr t (indent+1)
      goExpr v (indent+1)
      goExpr b (indent+1)
  | lit (Literal.natVal n) => dumpX <| "lit=" ++ toString n
  | lit (Literal.strVal s) => dumpX <| "lit=" ++ s
  | mdata _md _e => dumpX "mdata"
  | proj _n _ix _e => dumpX "proj"


def walkExpr (thing : Syntax) : TermElabM Expr := do
  let thingExpr ← elabTerm thing Option.none
  let _e ← getEnv
  let et ← inferType thingExpr
  IO.println "thing type: "
  goExpr et 0
  IO.println "thing expression: "
  goExpr thingExpr 0
  --logInfo <| thingExpr
  pure <| Lean.mkConst `Nat.zero


-- The forall value in a type is basically an argument: forall x (forall y z) is "x → y → z"
-- This takes the set of nested foralls and breaks them into a list of argument types
def unfoldForalls : Expr → List Expr
| forallE _n a rest _ => a :: unfoldForalls rest
| x => [x]

-- given some name from a ConstantInfo returns true if this is a match call (match_1, match_2, etc.)
def isMatchCall : Name → Bool := fun n =>
    match n.components.getLast? with
    | Option.none => false
    | Option.some v => String.isPrefixOf "match_" v.toString


elab "walkExpr" thing:term : term => walkExpr thing



def wormholeResult : Bool → Type
    | true => Syntax
    | false => Expr

def wormholePure {applyTransformers : Bool} (message : String) : TermElabM (wormholeResult applyTransformers) :=
    match applyTransformers with
    | true => pure <| (Syntax.mkStrLit message : Syntax)
    | false => pure <| Lean.mkStrLit message

-- A TransformerApp takes a list of arguments (as Exprs) and a recursive function to
-- call on child Expr's (this will usually be runWormhole partially applied to a transformer list) and constructs an
-- Expr from that.
def TransformerAppSyntax : Type := Array Expr → ((a : Bool) → Array Expr → Expr → TermElabM (wormholeResult a)) → TermElabM Syntax

-- wormhole re-written to find function applications
partial def wormhole2 (transformers : RBMap String TransformerAppSyntax compare) (applyTransformers : Bool) (argStack : Array Expr) (e : Expr) : TermElabM (wormholeResult applyTransformers) := do
    let e ← instantiateMVars e
    match e with
    | .app _ _ => do
        let fn := e.getAppFn
        let args := e.getAppArgs
        wormhole2 transformers applyTransformers (Array.append args argStack) fn
    | .const c _ => do
        logInfo <| "const: " ++ (String.intercalate "/" <| c.components.map toString)
        logInfo argStack
        match c.components.getLast? with
        | .none => wormholePure "app, no function name!"
        | .some n => do
            --logInfo (← e.getAppArgs.mapM instantiateMVars)
            --pure <| mkStrLit ("app,  function name = " ++ n.toString)
            let tr := transformers.find? n.toString
            match tr with
            | .some tf => match applyTransformers with
                | false => do
                    logInfo <| "stopping unfold at " ++ n.toString
                    pure e
                | true => do
                    let tresult ← tf argStack (wormhole2 transformers)
                    logInfo <| "transform result for " ++ n.toString ++ " :"
                    --logInfo tresult
                    pure tresult
            | .none => do
                let env ← getEnv
                let v := env.find? c
                match v with
                | Option.none => wormholePure <| "Cannot find constant named: " ++ c.toString
                | Option.some cr => do
                    match cr.value? with
                    | Option.none => do
                        logInfo <| match cr with
                                    | .axiomInfo _ => "const axiom"
                                    | .defnInfo _ => "const defn"
                                    | .thmInfo _ => "const thm info"
                                    | .opaqueInfo v => "const opaque info: " ++ String.join (v.all.map toString)
                                    | .quotInfo _ => "const quot"
                                    | .inductInfo _ => "const inductInfo"
                                    | .ctorInfo _ => "const ctorinfo"
                                    | .recInfo _ => "const recInfo"
                        -- constructors are assembled and returned if we're not transforming, so that
                        -- projections can properly deconstruct them
                        if cr.isCtor
                        then match applyTransformers with
                             | true => wormholePure <| "Found constructor const - " ++ c.toString
                             | false =>  pure <| mkAppN e argStack
                        else do
                            logInfo <| String.join <| (env.extraConstNames.toList.map (fun ees => ees.toString))
                            wormholePure <| "No value for const - " ++ c.toString
                    | Option.some s => wormhole2 transformers applyTransformers argStack s
    | .lam bn _bt body _bi => do
        --logInfo <| "lambda, arg name=" ++ bn.toString ++ ", args=" ++ argStack.toList.toString
        if argStack.size = 0
        then do
            --logInfo "no args for lambda"
            wormhole2 transformers applyTransformers #[] body
        else do
            let argsUsed := e.getAppNumArgs
            let result := e.beta argStack
            let betaArgs := argStack.toSubarray argsUsed 
            --logInfo "beta reduce result:"
            --logInfo result
            --pure <| mkStrLit "lambda"
            wormhole2 transformers applyTransformers #[] result
    | .proj _ty idx struct => do
        --logInfo <| "index for project : " ++ (toString idx)
        --logInfo struct
        -- for a projection we need to lookup the struct and then find the relevant field
        let structVal ← wormhole2 transformers false argStack struct
        let structType ← inferType struct
        --logInfo "struct after transform:"
        --logInfo <| (structVal : Expr)
        --logInfo structType
        let env ← getEnv
        let structName := structType.getAppFn
        let structArgs := structVal.getAppArgs
        --logInfo <| "structname: " ++ structName
        match structName with
        | .const c _ => do
            match env.find? c with
            | .some (.ctorInfo cval) => do
                --logInfo "struct ctor info: "
                --logInfo <| toString cval.cidx
                wormholePure "struct was constructor, oops"
            | .some (.inductInfo ival) => do
                --logInfo <| "inductive name : " ++ toString ival.name
                --logInfo <| String.intercalate "/" <| ival.ctors.map toString
                --logInfo <| "nParams=" ++ toString ival.numParams ++ " nIndices=" ++ toString ival.numIndices
                match env.find? (ival.ctors.get! 0) with
                | .some (.ctorInfo cinfo) => do
                    --logInfo <| "cinfo fields=" ++ toString cinfo.numFields
                    --logInfo <| "cinfo params=" ++ toString cinfo.numParams
                    let structFields := List.take cinfo.numFields <| structArgs.toList.drop cinfo.numParams
                    let projResult := structFields.get! idx
                    let reducedArgs := structArgs.toList.drop (cinfo.numParams + cinfo.numFields)
                    let projExpr := mkAppN projResult (reducedArgs.toArray)
                    --logInfo <| "after projection: "
                    --logInfo projExpr
                    wormhole2 transformers applyTransformers #[] projExpr
                | _ => wormholePure "invalid struct contructor"
            | _ => wormholePure <| "invalid lookup of struct " ++ toString c
        | _ => wormholePure "struct has no name"
    | .letE varName ty value body _ => do
        logInfo <| "letE: " ++ varName
        logInfo body
        logInfo argStack
        let b := body.instantiate1 value
        wormhole2 transformers applyTransformers #[] b
    | .bvar i => wormhole2 transformers applyTransformers #[] (argStack.get! i)
    | .fvar _ => do
        --logInfo <| "don't know what to do with fvar:" ++ toString e
        wormholePure "fvar"
    | .mvar vid => do
        --logInfo <| "don't know what to do with mvar:" ++ toString e
        let mc ← getMCtx
        let inf ← vid.getDecl
        --logInfo <| "mvar decl: " ++ inf.type
        --logInfo <| "metacontext size : " ++ toString (mc.decls.size)
        mc.decls.forM <| fun i _ => do 
            --logInfo (i.name)
            match mc.findDecl? i with
            | .some v => do
                /-logInfo <| "decl: " ++ toString v.lctx.size
                v.lctx.forM <| fun l => do
                    logInfo <| "local decl: " ++ toString l.fvarId.name-/
                pure ()
            | .none=> pure ()
        wormholePure "mvar"
    | .sort _ => do
        --logInfo <| "don't know what to do with sort:" ++ toString e
        wormholePure "sort"
    | .mdata _ _ => do
        logInfo <| "don't know what to do with mdata:" ++ toString e
        wormholePure "mdata"
    | _ => do
        logInfo <| "zort! I don't know what to do with expression term: " ++ ctorName e ++ " " ++ toString e
        wormholePure <| "zort" ++ ctorName e ++ "/" ++ toString e

syntax (name := wormholed) "goWormhole2" term : term

set_option hygiene false in
elab "genWormhole2" wormholeName:ident " >: " transforms:term " :< " : command => do
    let skelCommand ← 
        `(@[term_elab Wormhole.wormholed]
          def $wormholeName : TermElab := fun stx _ => do
              let e ← elabTerm (Syntax.getArg stx 1) Option.none
              let newS ← wormhole2 $transforms true #[] e
              elabTerm newS .none -- (.some typeTarget)
         )
    elabCommand skelCommand


--genWormhole2 yy >: RBMap.empty :<
--set_option pp.explicit true
--#eval goWormhole2 ((3 : Nat) + 3)
--def y :=  (fun x => match x with |Nat.zero => 0 | Nat.succ _ => 1)
--#eval goWormhole2 ((fun x => match x with |Nat.zero => 0 | _ => 1) : Nat → Nat) 

-- type of a function to transform a specific effect data instance: first argument is the type of the
-- effect op, and second argument is the actual op value
def ProcessEffect := Expr → Expr → TermElabM Syntax

-- higher-order effect processors work like `ProcessEffect` but have a third
-- argument that is the fork Expr. Also includes the recursive wormhole function so that branches/forks can be transformed
def ProcessHEffect := Expr → Expr → Expr → (rec : (a : Bool) → Array Expr → Expr → TermElabM (wormholeResult a)) → TermElabM Syntax  

--
-- this holds the relevant set of transformers for a specific effect or module. Typically you'll just have a single
-- entry in `effect` or `heffect` but some effect will have more complicated rules and requirements and might have more than
-- one entry in a field or more than one field filled in.
--
structure WormholeCallbacks : Type where
    effects : List (String × ProcessEffect)
    heffects : List (String × ProcessHEffect)
    direct : List (String × TransformerAppSyntax)


def effSyntaxMode (pr : TermElabM Syntax) : ProcessEffect := fun eff op => do
    withFreshMacroScope <| do
        let et ← inferType op
        let etStx ← `(?et)
        let opStx ← `(?op)
        let etVar ← elabTerm etStx .none
        let opVar ← elabTerm opStx (.some et)
        etVar.mvarId!.assign et
        opVar.mvarId!.assign op
        let f ← pr
        `($(TSyntax.mk f) ?et ?op)

-- given some effect name, figures out which processor to use for that effect
def dispatchEffectProcessor : List (String × ProcessEffect) → ProcessEffect := fun pr eff op => do
    match eff.getAppFn with
    | .const effName lvls => do
        let eNameEnd := effName.components.getLastD "_"
        match List.lookup eNameEnd.toString pr with
        | .some fm => fm eff op
        | .none => `("no handler for effect " ++ $(Syntax.mkStrLit effName.toString))
    | _ => `("malformed effect")

def dispatchHEffectProcessor : List (String × ProcessHEffect) → ProcessHEffect := fun transformers heff cmd fork rec =>
    match heff.getAppFn with
    | .const c levels => do
        logInfo "heffect..."
        --logInfo fork
        match c.components.getLast? with
        | .some i => do
            let z := Syntax.mkStrLit i.toString
            match transformers.lookup i.toString with
            | .some tr => tr heff cmd fork rec
            | .none => `("unhandled effect: " ++ $z)
        | .none =>
            let z := Syntax.mkStrLit c.toString
            `("unnamed heff" ++ $z)
    | _ => `("heffX error")

def stripLambda : Expr → Expr
    | .lam n arg b bi => b 
    | e@_ => e

partial
def unfoldListExpr (e : Expr) : MetaM (List Expr) := do
    --logInfo e
    --goExpr e 0
    let constr := e.getAppFn
    match constr.constName? with
    | .some n => do
        --logInfo <| "constructor: " ++ n.toString
        if n.toString == "List.cons"
        then do
            logInfo "CONS!"
            let args := e.getAppArgs
            let head := args[1]!
            let tail ← unfoldListExpr args[2]!
            pure <| head :: tail
        else if n.toString == "List.nil"
        then do
            --logInfo "NULL!"
            pure []
        else do
            --logInfo "???"
            pure []
    | .none => pure []


-- Try to "unfold" the fork element of a Hefy data element.
-- We for two forms : (fun x => match with |a => ... | b => ...) and (fun ix => [a,b,c][ix])
-- If it's neither of these the function returns .none
def unfoldFork (e : Expr) : MetaM (Option (Array Expr)) :=
    let x := stripLambda e
    if x.isApp
    then do
        let f := x.getAppFn
        match f.constName? with
        | .some n => do
            logInfo <| "fork app is : " ++ n
            let c := n.components.getLastD ""
            if "match".isPrefixOf c.toString
            then do
                let args := x.getAppArgs
                --logInfo <| "fork has " ++ (toString args.size) ++ " args"
                --logInfo args
                let branches := args.toList.drop 3
                let branches := branches.map stripLambda
                pure <| .some branches.toArray
            else if c == "getElem"
            then do
                let args := x.getAppArgs
                let branches ← unfoldListExpr <| args.toList.getD 3 (mkStrLit "error")
                pure <| .some (List.toArray branches)
            else if c == "get"
            then do
                let args := x.getAppArgs
                logInfo <| args
                let branches ← unfoldListExpr <| args.toList.getD 1 (mkStrLit "error")
                pure <| .some (List.toArray branches)
            else pure <| .none    
        | .none => pure <| .none
    else pure .none


-- An endless loop - this is partial so the elaborator will hide it behind an `opaque` Expr,
-- but we can write a transformer specifically for foreverUntil that knows how to build the correct
-- FSM or other final data structure.
partial
def foreverUntil [Monad m] (mainLine : m Bool) : m Unit := do
    if (← mainLine)
    then pure ()
    else foreverUntil mainLine

end Wormhole
