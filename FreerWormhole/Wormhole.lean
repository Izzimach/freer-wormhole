-- Deconstruct freer monads generated by FreerMacro


import Lean
import Lean.Parser

open Lean Elab Expr Command Meta Term MVarId

namespace Wormhole

def spaceN (n : Nat) : String := String.mk <| List.replicate n ' '

partial
def goExpr (t : Expr) (indent : Nat) : MetaM Unit := do
  let preSpace := spaceN indent
  let dumpX := fun s => IO.println <| preSpace ++ s
  match (← instantiateMVars t) with
  | bvar ix => dumpX <| "bvar=" ++ toString ix
  | fvar fid => dumpX <| "fvar=" ++ toString fid.name
  | mvar mid => dumpX <| "mvar=" ++ toString mid.name
  | sort lvl => dumpX <| "sort"
  | const n levels => dumpX <| "const=" ++ n.toString
  | app f arg => dumpX "app "; goExpr f (indent+1); goExpr arg (indent+1)
  | lam n arg body _ => dumpX ("lam > " ++ n.toString); goExpr arg (indent+1); goExpr body (indent+1)
  | forallE n a b _ => dumpX ("forall " ++ n.toString); goExpr a (indent+1); goExpr b (indent+1)
--  | letE n t v b => dumpX ("let " ++ n.toString); goExpr t (indent+1); goExpr v (indent+1); goExpr (b.instantiate1 v) (indent+1)
  | letE n t v b _ => do
      dumpX ("let " ++ n.toString)
      goExpr t (indent+1)
      goExpr v (indent+1)
      goExpr b (indent+1)
  | lit (Literal.natVal n) => dumpX <| "lit=" ++ toString n
  | lit (Literal.strVal s) => dumpX <| "lit=" ++ s
  | mdata md e => dumpX "mdata"
  | proj n ix e => dumpX "proj"


def walkExpr (thing : Syntax) : TermElabM Expr := do
  let thingExpr ← elabTerm thing Option.none
  let e ← getEnv
  let et ← inferType thingExpr
  IO.println "thing type: "
  goExpr et 0
  IO.println "thing expression: "
  goExpr thingExpr 0
  --logInfo <| thingExpr
  pure <| Lean.mkConst `Nat.zero


-- The forall value in a type is basically an argument: forall x (forall y z) is "x → y → z"
-- This takes the set of nested foralls and breaks them into a list of argument types
def unfoldForalls : Expr → List Expr
| forallE n a rest _ => a :: unfoldForalls rest
| x => [x]

-- given some name from a ConstantInfo returns true if this is a match call (match_1, match_2, etc.)
def isMatchCall : Name → Bool := fun n =>
    match n.components.getLast? with
    | Option.none => false
    | Option.some v => String.isPrefixOf "match_" v.toString


elab "walkExpr" thing:term : term => walkExpr thing



def wormholeResult : Bool → Type
    | true => Syntax
    | false => Expr

def wormholePure {applyTransformers : Bool} (message : String) : TermElabM (wormholeResult applyTransformers) :=
    match applyTransformers with
    | true => pure <| (Syntax.mkStrLit message : Syntax)
    | false => pure <| Lean.mkStrLit message

-- A TransformerApp takes a list of arguments (as Exprs) and a recursive function to
-- call on child Expr's (this will usually be runWormhole partially applied to a transformer list) and constructs an
-- Expr from that.
def TransformerAppSyntax : Type := Array Expr → ((a : Bool) → Array Expr → Expr → TermElabM (wormholeResult a)) → TermElabM Syntax

-- wormhole re-written to find function applications
partial def wormhole2 (transformers : Std.RBMap String TransformerAppSyntax compare) (applyTransformers : Bool) (argStack : Array Expr) (e : Expr) : TermElabM (wormholeResult applyTransformers) := do
    let e ← instantiateMVars e
    match e with
    | .app _ _ => do
        let fn := e.getAppFn
        let args := e.getAppArgs
        wormhole2 transformers applyTransformers (Array.append args argStack) fn
    | .const c _ => do
        logInfo <| "const: " ++ (String.intercalate "/" <| c.components.map toString)
        logInfo argStack
        match c.components.getLast? with
        | .none => wormholePure "app, no function name!"
        | .some n => do
            --logInfo (← e.getAppArgs.mapM instantiateMVars)
            --pure <| mkStrLit ("app,  function name = " ++ n.toString)
            let tr := transformers.find? n.toString
            match tr with
            | .some tf => match applyTransformers with
                | false => do
                    logInfo <| "stopping unfold at " ++ n.toString
                    pure e
                | true => do
                    let tresult ← tf argStack (wormhole2 transformers)
                    logInfo <| "transform result for " ++ n.toString ++ " :"
                    logInfo tresult
                    pure tresult
            | .none => do
                let env ← getEnv
                let v := env.find? c
                match v with
                | Option.none => wormholePure "Cannot find constant named "
                | Option.some cr => do
                    match cr.value? with
                    | Option.none => do
                        -- constructors are assembled and returned if we're not transforming, so that
                        -- projections can properly deconstruct them
                        if cr.isCtor
                        then match applyTransformers with
                             | true => wormholePure <| "Found constructor const - " ++ c.toString
                             | false =>  pure <| mkAppN e argStack
                        else wormholePure <| "No value for const - " ++ c.toString
                    | Option.some s => wormhole2 transformers applyTransformers argStack s
    | .lam bn bt body bi => do
        logInfo <| "lambda, arg name=" ++ bn.toString ++ ", args=" ++ argStack.toList.toString
        if argStack.size = 0
        then do
            logInfo "no args for lambda"
            wormhole2 transformers applyTransformers #[] body
        else do
            let result := e.beta argStack
            logInfo "beta reduce result:"
            logInfo result
            --pure <| mkStrLit "lambda"
            wormhole2 transformers applyTransformers #[] result
    | proj ty idx struct => do
        logInfo <| "index for project : " ++ (toString idx)
        logInfo struct
        -- for a projection we need to lookup the struct and then find the relevant field
        let structVal ← wormhole2 transformers false argStack struct
        let structType ← inferType struct
        logInfo "struct after transform:"
        --logInfo <| (structVal : Expr)
        logInfo structType
        let env ← getEnv
        let structName := structType.getAppFn
        let structArgs := structVal.getAppArgs
        logInfo <| "structname: " ++ structName
        match structName with
        | .const c _ => do
            match env.find? c with
            | .some (.ctorInfo cval) => do
                logInfo "struct ctor info: "
                logInfo <| toString cval.cidx
                wormholePure "struct was constructor, oops"
            | .some (.inductInfo ival) => do
                logInfo <| "inductive name : " ++ toString ival.name
                logInfo <| String.intercalate "/" <| ival.ctors.map toString
                logInfo <| "nParams=" ++ toString ival.numParams ++ " nIndices=" ++ toString ival.numIndices
                match env.find? (ival.ctors.get! 0) with
                | .some (.ctorInfo cinfo) => do
                    logInfo <| "cinfo fields=" ++ toString cinfo.numFields
                    logInfo <| "cinfo params=" ++ toString cinfo.numParams
                    let structFields := List.take cinfo.numFields <| structArgs.toList.drop cinfo.numParams
                    let projResult := structFields.get! idx
                    let reducedArgs := structArgs.toList.drop (cinfo.numParams + cinfo.numFields)
                    let projExpr := mkAppN projResult (reducedArgs.toArray)
                    logInfo <| "after projection: "
                    logInfo projExpr
                    wormhole2 transformers applyTransformers #[] projExpr
                | _ => wormholePure "invalid struct contructor"
            | _ => wormholePure <| "invalid lookup of struct " ++ toString c
        | _ => wormholePure "struct has no name"
    | fvar _ => do
        logInfo <| "don't know what to do with fvar:" ++ toString e
        wormholePure "fvar"
    | mvar vid => do
        logInfo <| "don't know what to do with mvar:" ++ toString e
        let mc ← getMCtx
        let inf ← vid.getDecl
        logInfo <| "mvar decl: " ++ inf.type
        logInfo <| "metacontext size : " ++ toString (mc.decls.size)
        mc.decls.forM <| fun i d => do 
            logInfo (i.name)
            match mc.findDecl? i with
            | .some v => do
                logInfo <| "decl: " ++ toString v.lctx.size
                v.lctx.forM <| fun l => do
                    logInfo <| "local decl: " ++ toString l.fvarId.name
            | .none=> pure ()
        wormholePure "mvar"
    | sort _ => do
        logInfo <| "don't know what to do with sort:" ++ toString e
        wormholePure "sort"
    | mdata _ _ => do
        logInfo <| "don't know what to do with mdata:" ++ toString e
        wormholePure "mdata"
    | _ => do
        logInfo <| "zort! I don't know what to do with expression term:" ++ ctorName e ++ toString e
        wormholePure <| "zort" ++ ctorName e ++ "/" ++ toString e

syntax (name := wormholed) "goWormhole2" term : term



set_option hygiene false in
elab "genWormhole2" wormholeName:ident " >: " transforms:term " :< " : command => do
    let skelCommand ← 
        `(@[termElab Wormhole.wormholed]
          def $wormholeName : TermElab := fun stx _ => do
              let e ← elabTerm (Syntax.getArg stx 1) Option.none
              logInfo e
              let newS ← wormhole2 $transforms true #[] e
              --let typeTarget ← elabTerm (← `(FreerSkeleton [NoEffect,IOEffect] (ULift Nat))) .none
              elabTerm newS .none -- (.some typeTarget)
              --wormhole2 $transforms false #[] e
         )
    elabCommand skelCommand


genWormhole2 ww >: Std.RBMap.empty :<

set_option pp.explicit true

#eval goWormhole2 ((3 : Nat) + 3)
#eval goWormhole2 (fun x => match x with |Nat.zero => 0 |Nat.succ _ => 1)

end Wormhole
